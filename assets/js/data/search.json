[ { "title": "강의 필기 - 자바 ORM 표준 JPA 프로그래밍 - 기본편", "url": "/posts/jpa-basic/", "categories": "Studying, Notes", "tags": "", "date": "2022-07-11 19:00:00 +0900", "snippet": "자바 ORM 표준 JPA 프로그래밍 - 기본편JPA 소개장점 개발 속도 향상 유지보수성 증가실무에서 어려운 이유 객체와 테이블의 설계와 올바른 맵핑 JPA 내부 동작방식에 대한 이해JPA와 모던 자바 데이터 저장 기술SQL 중심적인 개발의 문제점 대부분 객체를 관계형 DB에 저장 관리. 모두 SQL 무한 반족, 지루한 코드 필드가 추가 되면 유지보수가 쉽지 않음. 패러다임의 불일치 객체 vs. 관계형 데이터베이스 상속 객체 존재 디비 X, 그나마 유사한 것이 “슈퍼타입 서브타입 관계” 연관관계 객체 : 참조 사용 테이블 : 외래 키 사용 데이터 타입 데이터 식별 방법 JPA Java Persistence API 자바 진영의 ORM 기술 표준 인터페이스의 모음JPA를 왜 사용해야 하는가? SQL 중심적인 개발에서 객체 중심으로 개발 생산성 저장 : jpa.persist(member) 조회 : jpa.find(member) 수정 : member.setName(“newName”) 삭제 : jpa.remove(member) 유지보수 필드 변경 시 SQL은 JPA가 해결 패러다임의 불일치 해결 상속 저장 : 알아서 2가지 insert 문 생성 조회 : 알아서 join 문 생성 연관관계 신뢰할 수 있는 엔티티 동인한 트랜잭션 내 조회한 엔티티는 같다. 성능 1차 캐시와 동일성 (identity) 보장 같은 트랜잭션 안에서는 같은 엔티티 반환 DB Isolation Level이 Read commit 이어도 애플리케이션에서 Repeatalbe Read 보장 트랜잭션을 지원하는 쓰기 지연 (transactional write-behind) 트랜잭션 커밋 전까지 SQL을 모았다가 한번에 전송 지연 로딩 (Lazy Loading) 객체가 실제 사용될 때 로딩 데이터 접근 추상화와 벤더 독립성 표준JPA 시작프로젝트 생성H2 데이터 베이스 설치와 실행IntelliJ 프로젝트 생성 JAVA 8 Maven pom.xml 설정 dependency 추가 h2database version은 다운한 것과 일치해야 함. JPA 설정하기 - persistence.xml 위치 : /META-INF/persistence.xml 데이터베이스 방언 hibernate.dialect 속성에 지정 원하는 특정 DB 기능 사용 원할 시. hibernate 전용 옵션 ERROR: Database \"/Users/이름/test\" not found, either pre-create it or allow remote database creation (not recommended in secure environments) [90149-214] 오류 해결 방법 : ./h2.sh 실행 종료 JDBC URL : jdbc:h2:~/test 로 접속 후 JDBC URL : jdbc:h2:tcp://localhost/~/test 로 다시 시도 애플리케이션 개발영속성 관리 - 내부 동작 방식영속성 컨텍스트 엔티티를 영구 저장하는 환경 EntityManager.persist(entity); 디비에 저장하는 것이 아니라, entity를 영속성 컨텍스트에 영구적으로 저장한다는 뜻. 엔티티의 생명 주기 비영속 (new/transient) 영속 (managed) 준영속 (detached) 삭제 (removed) 영속성 컨텍스트의 이점 1차 캐시 조회 시 DB에서 가져오기 전에 먼저 1차 캐시에서 가져온다. (select 쿼리 안 날림) 동일성 (identity) 보장 동일 객체 == 비교 시 true 트랜잭션을 지원하는 쓰기 지연 (transactional write-behind) 쓰기 지연 저장소에 SQL를 쌓아놓고 커밋하는 순간 한꺼번에 보낸다. &lt;property name=\"hibernate.jdbc.batch_size\" value=\"10\"/&gt; 변경 감지 (Dirty Checking) 엔티티와 스냅샷 비교 후 자동으로 UPDATE OR DELETE 지연 로딩 (Lazy Loading)플러시 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영. em.flush() - 직접 호출 트랜잭션 커밋 - 플러시 자동 호출 JPQL 쿼리 실행 - 플러시 자동 호출 1차 캐시를 지우는 것이 아님. 쓰기 지연 저장소에 있는 것들이 데이터베이스에 반영이 되는 것. 플러시 모드 옵션 FlushModeType.AUTO 커밋이나 쿼리를 실행할 때 플러시 (기본값) FlushModeType.COMMIT 커밋할 때만 플러시 준영속 상태 영속 상태의 엔티티가 영속성 컨텍스트에서 분리. 영속성 컨텍스트가 제공하는 기능을 사용 못함. em.detach(entity) 특정 엩티티만 준영속 상태로 전환. em.clear() 영속성 컨텍스트를 완전히 초기화. (1차 캐시 지움) em.close() 영속성 컨텍스트를 종료. 엔티티 매핑객체와 테이블 매핑 : @Entity, @Table @Entity JPA가 관리하는 엔티티 기본 생성자 필수 final 클래스, enum, interface, inner 클래스 사용 X 저장할 필드에 final 사용 X 속성 name (기본값 = Class 이름) @Table데이터베이스 스키마 자동 생성 어플리케이션 실행 시점에 DDL 자동 생성 객체 중심! 데이터베이스 방언을 활용해 DB에 맞는 적절한 DDL 생성 개발 장비에서만 사용 운영 서버에서는 적절히 다듬어서 사용 속성 create 시작 전 테이블 drop 후 생성 create-drop 시작 전 테이블 drop 후 생성 이후 종요 시점에서 다시 drop update 기존 테이블 drop 대신 alter 필드 삭제는 불가, 추가만 가능 validate 엔티티와 테이블이 정상 매핑되었는지 확인 none 기능을 사용 안 함. 운영 장비에서는 사용 X 필드와 컬럼 매핑 @Column 컬럼 매핑 @Temporal 날짜 타입 매핑 최신 버전 하이버네이트는 굳이 명시할 필요 없음 @Enumerated enum 타입 매핑 @Lob BLOB, CLOB 매핑 @Transient 특정 필드를 컬럼에 매핑하지 않음(매핑 무시) 기본 키 매핑 @Id 기본 키 값을 직접 할당 @GeneratedValue 함께 사용 시 값 자동 생성 IDENTITY 데이터베이스에 위임, MySQL 디비에 insert 돼야 기본 키 값을 알 수 있음. 그래서 예외적으로 persist() 실행 시 바로 insert 문을 날린다. (commit 까지 안 기다림) 이후 바로 select 해옴 (내부적으로 insert 시점에 바로 return 받음) SEQUENCE Long 사용 권장 데이터베이스 시퀀스 사용, Oracle @SequenceGenerator 필요 데이터베이스에 시퀀스 생성 시 기본 키 값을 알기 위해 “call next value for” 시퀀스가 persist 전에 실행 된다. allocationSize를 통해 성능 최적화 가능. call next value for을 매번 가져오는 대신 미리 설정 개수만큼 가져온다. 처음에 2번 호출해서 1, 개수 N+1, 그리고 그 다음부터는 메모리에서 호출 TABLE 키 생성 전용 테이블 하나 생성 후 시퀀스 흉내 모든 데이터베이스 적용 가능 @TableGenerator 필요 이것도 allocationSize 있음 권장하는 식별자 전략 Long 형 + 대체키 + 키 생성 전략 사용 연관관계 매핑 : @ ManyToOne, @JoinColumn연관관계 매핑 기초연관관계가 필요한 이유 객체를 테이블에 맞춰 모델링 시 외래 키 식별자를 직접 다룸 식별자로 다시 조회 객체 지향적이지 않음. 단방향 연관관계 @ManyToOne 객체지향적 객체 자체를 set 해서 가져올 때 알아서 join 하는 객체의 기본키를 가져옴.양방향 연관관계와 연관관계의 주인 @ManyToOne &lt;-&gt; @OneToMany 역방향도 조회 가능 객체의 양방향 관계 서로 다른 두 개의 단방향 관계 테이블의 양방향 관계 외래 키 하나로 양방향 관계 연관관계 주인 (Owner) 주인 mappedBy 속성 X 외래 키가 있는 곳 주인 X mappedBy 속성으로 주인 지정 양방향 매핑 시 가장 많이 하는 실수 연관관계의 주인에 주인 아닌 것들의 값을 입력 안 함. 주인 아닌 것에 주인의 값을 입력 안 해도 호출 시 JPA가 자동으로 select 문을 날려서 가져온다. (flush(), clear() 시) 하지만 순수 객체 상태를 고려하면 (flush(), claer() 안 하면 영속성 상태, 1차 캐시에 없음, 조회 안 됨.) 양쪽에 모두 값을 입력해줘야 한다. 실수 방지를 위해 주인에 값 세팅 시 그 메소드 안에서 반대 방향의 객체에 자기 자신을 입력해 준다. (this) 연관관계 편의 메소드 이용 (Setter 대신 권장) 아무쪽에나, 둘 중 하나에 메소드 생성 무한 루프 조심! 양방향 매핑 정리 단반향 매핑만으로도 이미 연관관계 매핑은 완료. 양방향 매핑은 역방향 조회 (객체 그래프 탐색) 기능이 추가된 것 뿐. JPQL에서 역방향으로 탐색할 일이 많음. 단방향 매핑을 잘하고 양방향은 필요할 때 추가해도 됨. 테이블에 영향을 주지 않음. 다양한 연관관계 매핑연관관계 매핑 시 고려사항 3가지 다중성 다대일 (@ManyToOne) 일대다 (@OneToMany) 일대일 (@OneToOne) 다대다 (@ManyToMany) 단방향 , 양방향 연관관계의 주인다대일 [N : 1] 단방향 가장 많이 사용. 반대는 일대다. 양방향 왜래 키가 있는 쪽이 주인. 양쪽을 서로 참조. 일대다 [1 : N] 단방향 1이 연관관계 주인. 다 쪽에 외래 키 있음. 여기를 추가 Update 침. @JoinColumn 필수. 비추. 일대다 단방향 보다는 다대일 양방향 매칭 권장. 양방향 공식적으로 존재 X @JoinColumn (inserttable = false, updatable = false) 읽기 전용 필드 다대일 양방향 사용 권장. 일대일 [1:1] 외래 키 위치 선택 가능. 유니크 제약 조건 추가 필요 주 테이블에 왜래 키 단방향 다대일과 유사. 주 테이블에 외래키 양방향 외래키가 있는 곳이 주인. 대상 테이블에 외래 키 단방향 JPA 지원 X 대상 테이블에 외래 키 양방향 주 테이블 왜래 키 양방향과 매핑 방법 같음. 다대다 [N : M] 관계형 디비에서는 표현 불가. 연결 테이블 추가해서 일대다, 다대일 관계로 풀어내야 함. 객체는 가능.고급 매핑상속 관계 매핑 객체의 상속 구조와 데이터베이스의 슈퍼타입 서브타임 관계를 매핑 부모 클래스는 추상 클래스 슈퍼타입 서브타입 논리 모델 -&gt; 물리 모델 전환 방법 조인 전략 단일 테이블 전략 구현 클래스마다 테이블 전략 @Inheritance(strategy=Inheritance.Type.XXX) JOINED : 조인 전략 insert 쿼리 2번 조회 시 join 사용. SINGLE_TABLE : 단일 테이블 전략 insert 쿼리 1번 조회 시 join 필요 없음. TABLE_PER_CLASS : 구현 클래스마다 테이블 전략 부모 테이블 존재 X. 자식들에 부모 테이블에 있던 필드들이 중복으로 들어감. 부모 객체로 조회 시 모든 테이블 조회 필요 -&gt; 긴 쿼리 수행, 성능 안 좋음. @DiscriminatorColumn DTYPE이 자동으로 테이블에 컬럼으로 생김. 자식 객체명이 들어감. @DiscriminatorValue(“뭥하는 값”)으로 변경 가능. 단일 테이블 전략에서는 필수! @MappedSuperclass 공통 매핑 정보가 필요할 때 사용 각 클래스에서 중복 되는 필드 e.g. id, name 공통 필드를 가진 클래스에 명시 조회, 검색 불가. 추상 클래스 권장프록시와 연관관계 관리프록시 em.find() 디비를 통해 실제 엔티티 객체 조회. em.getReference() 디비 조회를 미루는 가짜 (프록시) 엔티티 객체 조회. 프록시 특징 처음 사용 시 딱 한번만 초기화 초기화 시 실제 엔티티에 접근, NOT 실제 엔티티로 치환. 원본 엔티티를 상속 받음. 영속성 컨텍스트에 이미 찾는 엔티티가 있다면, getReference()도 실제 엔티티 반환. 프록시를 먼저 호출 했으면 후에 find()도 프록시 반환. 준영속 상태일 때 프록시 초기화 하면 문제 발생 즉시 로딩과 지연 로딩 지연 로딩 (fetch = FetchType.LAZY) 프록시로 조회 연관관계가 있는 클래스를 사용하는 시점에서 초기화 즉시 로딩 (fetch = FetchType.EAGER) 프록시가 아닌 실제 엔티티 바로 조회. (연관관계가 있는 클래스까지) 문제점 JPQL에서 N+1 문제를 일으킨다. 지연 로딩 활용 자주 함께 사용 -&gt; 즉시 로딩 가끔 사용 -&gt; 지연 로딩 하지만 실무에서는 무조건 지연 로딩만 써야 한다 영속성 전이 (CASCADE)와 고아 객체 영속성 전이 특정 엔티티를 영속 상태로 만들 때 연관된 엔티티도 함께 영속 상태로 만들고 싶을 때 (cascade = CascadeType.ALL) persist(parent) 하면, child까지 전부 저장된다. Parent 와 Child의 Life Cycle이 거의 똑같을 때, 단일 소유자 (child)일 때 사용 권장. 고아 객체 고아 객체 제거 (orphanRemoval = true) 부모 객체에서 제거된 자식 객체를 자동으로 Delete 쿼리를 날려 제거. 참조하는 곳이 하나일 때 사용. 영속성 전이 + 고아 객체 생명 주기 부모 엔티티를 통해서 자식 생명 주기를 관리할 수 있음. 도메인 주도 설계(DDD)의 Aggregate Root 개념을 구현할 때 유용. 값 타입기본값 타입 엔티티 타입 @Entity 데이터가 변해도 식별자로 지속해서 추적 가능. 값 타입 int, Integer, String 처럼 단순히 값으로 사용하는 자바 기본 타입이나 객체. 식별자 X, 추적 불가. 분류 기본값 타입 자바 기본 타입 (int, double) 래퍼 클래스 (Integer, Long) String 임베디드 타입 (embedded type, 복합 값 타입) 컬렌셕 값 타입 (collection value type) 기본값 타입 생명 주기를 엔티티에 의존 값 타입은 공유하면 안 됨. 자바의 기본 타입은 절대 공유 안 됨. 기본 타입은 항상 값을 복사함. 임베디드 타입 (복합 값 타입) 새로운 값 타입을 직접 정의할 수 있음. JPA는 임베디드 타입. int, String과 같은 값 타입. @Embeddable 값 타입을 정의하는 곳 @Embedded 값 타입을 사용하는 곳 기본 생성자 필수 장점 재사용 높은 응집도 해당 값 타입만 사용하는 의미있는 메소드 생성 가능. 값 타입을 소유한 엔티티에 생명 주기를 의존. 임베디드 타입과 테이블 매핑 임베디드 타입은 엔티티의 값일 뿐이다. 임베디드 타입을 사용하기 전과 후에 매핑하는 테이블은 같다. 객체와 테이블을 아주 세밀하게(find-grained) 매핑하는 것이 가능. 잘 설계한 ORM 애플리케이션은 매핑한 테이블의 수보다 클래스의 수가 더 많음.임베디드 타입과 연관관계 @AttributeOverrides, @AttributeOverride 한 엔티티 안에 같은 임베디드 타입을 사용 시 필요 컬럼 명 속성 재정의 임베디드 타입과 NULL 임베디드 타입 자체 값이 NULL이면 매핑한 컬럼 값 모두 NULL.값 타입과 불변 객체 값 타입 공유 참조 임베디드 타입 같은 값 타입을 여러 엔티티에서 공유하면 위험. 부작용(side effect) 발생 대신, 값을 복사해서 사용 객체 타입의 한계 참조 값을 직접 대입하는 것을 막을 방법이 없다. 공유 참조를 피할 수 없다. 불변 객체 부작용 원천 차단. 생성 시점 이후 절대 값을 변경할 수 없는 객체 생성자로만 값을 설정하고 Setter를 만들지 않으면 됨. 값 타입의 비교 인스턴스가 달라도 그 안에 값이 같으면 같은 것. 동일성(identity) 비교 인스턴스의 참조 값을 비교 == 사용 동등성(equivalence) 비교 인스턴스의 값을 비교 equals() 사용 값 타입은 equals() 사용 메소드를 적절하게 재정의 필요 값 타입 컬렉션 값 타입을 하나 이상 저장할 때 사용. @ElementCollection @CollectionTable 컬렉션 저장을 위한 별도의 테이블 필요. 값 타입 수정 Setter 사용 대신 엔티티 안의 Setter로 그냥 통으로 new 해서 새롭게 값을 수정한다 컬렉션은 remove() 후 새로운 거 다시 add() equals()가 제대로 Override 되어있어야 한다. 변경 사항이 발생하면, 주인 엔티티와 연관된 모든 데이터를 삭제하고, 값 타입 컬렉션에 있는 현재 값을 모두 다시 저장한다. 값 타입 컬렉션 대안 일대다 관계를 위한 엔티티를 만들고, 여기서 값 타입 사용. 영속성 전이 + 고아 객체 제거를 사용. 객체지향 쿼리 언어1 - 기본 문법JPQL Java Persistence Query Language JPA는 SQL을 추상화한 JPQL이라는 객체지향 쿼리 언어 제공 테이블이 아닌 엔티티 객체를 대상으로 쿼리 특정 데이터베이스에 의존 XCriteria 소개 문자가 아닌 자바 코드로 JPQL 작성 가능. JPQL 빌더 역할 JPA 공식 기능 단점 : 너무 복잡하고 실용성이 없다. 대안으로 QueryDSL 사용 권장 QueryDSL 소개 문자가 아닌 자바 코드로 JPQL 작성 가능. JPQL 빌더 역할 동적 쿼리 작성 편리 단순하고 쉬움 실무 사용 권장!네이티브 SQL 소개 JPA가 제공하는 SQL을 직접 사용하는 기능. JPQL로 해결할 수 없는 특정 데이터베이스에 의존적인 기능 사용 가능. JPA를 사용하면서 JDBC 커넥션을 직접 사용하거나, 스프링 JDBC Template, 마이바티스 등을 함께 사용 가능. 단, 영속성 컨텍스트를 적절한 시점에 강제로 플러시 필요.기본 문법과 쿼리 APIJPQL 문법 엔티티와 속성은 대소문자 구분 JPQL 키워드는 대소문자 구분 X 엔티티 이름 사용 테이블 이름 X 별칭은 필수 as는 생략 가능 집합과 정렬 Group By, Having Order byTypeQuery, Query TypeQuery 반환 타입이 명확할 때 사용 Query 반환 타입이 명확하지 않을 때 사용 결과 조회 API query.getResultList() 결과가 하나 이상일 때, 리스트 반환 결과가 없으면 빈 리스트 반환 NullPointerException 걱정 X query.getSingleResult() 결과가 정확히 하나, 단일 객체 반환 결과가 없으면 : javax.persistence.NoResultException 둘 이상이면 : javax.persistence.NoUniqueResultException 파라미터 바인딩 이름 기준 :파라미터 setParameter(“파라미터”, 값) 위치 기준 ?1 setParameter(1, 값) 프로젝션 (SELECT) select 절에 조회할 대상을 지정하는 것. 프로젝션 대상 엔티티 SELECT m FROM Member m SELECT m.team FROM Member m 영속성 컨텍스트에 올라감. 임베디드 타입 ELECT m.address FROM Member m 스칼라 타입 SELECT m.username, m.age FROM Member m 여러 값 조회 Query 타입으로 조회 Object[] 타입으로 조회 new 명령어로 조회 단순 값을 DTO로 바로 조회 " }, { "title": "강의 필기", "url": "/posts/springboot+jpa/", "categories": "Studying, Notes", "tags": "", "date": "2022-06-08 15:04:00 +0900", "snippet": "실전! 스프링 부트와 JPA 활용1 - 웹 애플리케이션 개발프로젝트 환경 설정H2 데이터베이스 설치H2 데이터베이스 : 개발이나 테스트 용도로 가볍고 편리한 DB, 웹 콘솔 환경 제공https://h2database.com/html/main.html맞는 버전 (.zip) 다운로드 후 h2/bin 위치에서 JAVA로 실행되기 때문에 JAVA 설치 필수 나는 위와 같이 오류가 발생해 파일 실행 권한을 추가해 주었다.JDBC URL : jdbc:h2:~/jpashop -&gt; 연결JDBC URL : jdbc:h2:tcp://localhost/~/jpashop -&gt; 연결 DB 파일 생성할 때만 파일 모드, 이후는 네트워크 모드로 접근 h2.sh를 항상 실행해놔야 DB 동작 가능JPA와 DB 설정, 동작 확인spring: datasource: url: jdbc:h2:tcp://localhost/~/jpashop; hikari: username: sa password: driver-class-name: org.h2.Driverjpa: hibernate: ddl-auto: create #어플리케이션 실행 시점에 내가 가지고 있는 테이블을 모두 지운 뒤 다시 생성 properties: hibernate:# show_sql: true # 아래 logging 설정과 같으나 System.out 을 통해 보임. formate_sql: truelogging: level: org.hibernate.SQL: debug #hibernate가 생성하는 SQL이 다 보인다. (logger를 통해)" }, { "title": "깃허브 블로그 글 조회수 기능 추가 일단 실패 (Chirpy 테마)", "url": "/posts/page-views/", "categories": "Blogging, Tutorial", "tags": "github, blog, jekyll, chirpy, google analytics", "date": "2022-03-31 18:20:00 +0900", "snippet": "서론내가 쓴 글을 과연 나 말고 다른 사람들이 보기는 할까? 문득 궁금해져서 귀찮아서 추가하지 않으려던 조회수 기능을 추가해 보려고 한다. Chirpy 공식 설명 문서를 따라 해보자. 이 문서에는 조회수가 낮다면 블로그 글 쓸 맛이 안 날 수 있으니 주의하라는 재밌는 경고가 쓰여져 있지만, 나는 조회수에 딱히 집착하지 않으니 가뿐히 무시하고 시작한다. 아무도 안 보면 내가 얼마나 들락날락하는지 알아보는 용도로 쓰지 뭐..,,시작~~~~Google Analytics 계정 만들기https://analytics.google.com/ 들어가서 측정 시작 : 계정 설정 : 원하는 계정 이름, 계정 데이터 공유 설정을 한다. 나는 그냥 체크된 대로 진행했다. 속성 설정 : 속성 이름, 보고 시간대, 통화 설정 나중에 수정이 가능하다고 하니 대충 설정하면 될 듯하다. 속성 이름은 알아보기 쉽게 블로그 이름으로 했다. 비지니스 정보 딱 봐도 귀찮아 보여서 굳이 써야하나 하고 바로 만들기를 눌렀더니 그대로 진행됐다. 설정 안 해도 괜찮은 것 같다. 만들기를 누르면 아래와 같이 약관 계약 창이 뜨고 동의함 누르면 완료!데이터 스트림 만들기계정을 만들면 바로 데이터 스트림 설정 창으로 넘어갈 것이다. 그렇지 않다면 직접 찾아서 들어가자. 좌측 상단 관리자 -&gt; 원하는 속성 클릭 (방금 만든 속성 이름) -&gt; 데이터 스트림 자 이제 플랫폼을 웹으로 선택하면 데이터 스트림 설정 창이 뜬다.본인의 블로그 주소와 스트림 이름을 적자. 난 그냥 똑같이 블로그 이름 썼다.그리고 스트림 만들기를 누르면,,,,…짜잔~~ 위와 같이 웹 스트림 세부 정보 창이 뜬다. G-XXXXXXXXXX 형식의 측정 ID를 복사해서 _config.yml 파일로 가보자.google_analytics: id: 'G-XXXXXXXXXX' # 본인의 측정 ID # Google Analytics pageviews report settings pv: proxy_endpoint: # fill in the Google Analytics superProxy endpoint of Google App Engine cache_path: # the local PV cache data, friendly to visitors from GFW region_config.yml 파일 내 위 부분을 찾아 측정 ID를 넣고 저장 후 git push를 해주면,일정 시간이 지난 후 아래와 같이 실시간으로 통계를 확인할 수 있다.조회수 설정여기서 상새한 설명을 확인할 수 있지만 난 그냥 빨리 Chirpy를 이용해 블로그 글 조회수만 확인하고 싶을 뿐이다.Google App Engine 셋업 https://console.cloud.google.com/appengine 접속, 약관 동의 후, 프로젝트 만들기 흠, 프로젝트 이름을 적은 후 가까운 데이터 센터를 지정해야 했지만 이번에도 역시 그냥 만들기를 누르니까 만들어졌다. 일단 계속 해보자. 앱 만들기 문서에는 앱 만들기 후 프로젝트 만들기라 되어있는데 난 왜 반대지? 일단 내 맘대로 진행해 본다. 한국으로 설정하고 다음 언어 = Python, 환경 = 표준으로 하고 나중에 배포 API 및 서비스 (좌측 상단 탐색 메뉴 안에 있음) + API 및 서비스 사용 설정 -&gt; Google Analytics API 검색 -&gt; 사용 OAuth 동의 화면 -&gt; User Type 외부 선택 -&gt; 만들기 OAuth 동의 화면 만들기에 대한 자세한 설명은 없다. 대충 Google Analytics API를 사용하기 위해 사용자에게 보여지는 동의 화면에 대한 설정인 것 같은데, 이전과 마찬가지로 나는 그냥 필수 항목만 채워넣고 계속 다음 단계로 진행하여 완료했다. 사용자 인증 정보 -&gt; + 사용자 인증 정보 만들기 -&gt; OAuth 클라이언트 ID -&gt; 애플리케이션 유형 웹 애플리케이션 -&gt; 이름 작성 -&gt; 승인된 리디렉션 URI :https://&lt;project-id&gt;.&lt;region&gt;.r.appspot.com/admin/auth project-id : 홈의 프로젝트 정보나 프로젝트 선택 시 ID를 확인할 수 있다. region : 앱 만들기에서 선택했던 리전 같다,, 스크린샷 해놓은 덕분에 살았다,… 그럼 아래와 같이 OAuth 클라이언트가 생성된 것을 확인할 수 있다. 딱 봐도 중요해 보이니 잘 적어 놓자. Cloud SDK 다운로드 :https://cloud.google.com/sdk/docs/quickstart 이전에 프로젝트에 결제 정보를 등록하지 않았다면, 구글 클라우드 플랫폼 최상단에 계속 뜨는 광고 활성화를 누르거나 탐색 메뉴 -&gt; 결제 -&gt; 결제 계정 연결에서 등록해주면 된다. 블로그에 사용하기엔 무료로 제공되는 크레딧이 충분하기 때문에 추가 결제에 대한 걱정은 안 해도 된다고 한다. 링크에서 본인에게 맞는 패키지를 다운하고 압축 파일 해제 후 $ ./google-cloud-sdk/install.sh 까지 실행해야 완료된다. 다운로드 과정을 캡처로 다 떠놨지만 귀찮아서 생략한다. 필요한 분이 생긴다면 추후에 업데이트 하겠다. 명령어 실행 : $ gcloud init 를 실행하면 위와 같이 뜨고 , y 엔터를 하면 크롬 창이 열리면서 로그인 인증이 진행된다. 그 이후, 콘솔창에서 위와 같이 확인할 수 있고, 1을 입력하면 Your current project has been set to: [프로젝트 ID]. 라는 문구와 함께 주르륵 어쩌구 저쩌구 안내 문구들이 뜬다. $ gcloud info 마지막으로 위 명령어를 입력하면 현재 프로젝트에 관한 정보들을 확인할 수 있다. Google Analytics superProxy 셋업 깃허브에서 Google Analytics superProxy를 로컬에 클론 해오자 : $ git clone https://github.com/googleanalytics/google-analytics-super-proxy src/app.yaml 파일의 첫 2줄 삭제 : ```yaml application: your-project-id version: 1 ``` In src/config.py, 아까 잘 적어놓은 OAUTH_CLIENT_ID 와 OAUTH_CLIENT_SECRET를 입력하자. XSRF_KEY에는 자기만 알 수 있는 아무말을 적는다.config.py 파일 예시 : #!/usr/bin/python2.7 __author__ = 'pete.frisella@gmail.com (Pete Frisella)' # OAuth 2.0 Client Settings AUTH_CONFIG = { 'OAUTH_CLIENT_ID': 'YOUR_CLIENT_ID', 'OAUTH_CLIENT_SECRET': 'YOUR_CLIENT_SECRET', 'OAUTH_REDIRECT_URI': '%s%s' % ( 'https://chirpy-test-XXXXXX.ue.r.appspot.com', '/admin/auth' ) } # XSRF Settings XSRF_KEY = 'OnceUponATimeThereLivedALegend' 클론한 폴더 내 src/ 에서, 아래와 같이 콘솔에 명령어 수행 : [root@bc96abf71ef8 src]# gcloud app deployServices to deploy:descriptor: [/tmp/google-analytics-super-proxy/src/app.yaml]source: [/tmp/google-analytics-super-proxy/src]target project: [chirpy-test-XXXX]target service: [default]target version: [VESRION_NUM]target url: [https://chirpy-test-XXXX.ue.r.appspot.com]Do you want to continue (Y/n)? YBeginning deployment of service [default]...╔════════════════════════════════════════════════════════════╗╠═ Uploading 1 file to Google Cloud Storage ═╣╚════════════════════════════════════════════════════════════╝File upload done.Updating service [default]...done.Setting traffic split for service [default]...done.Deployed service [default] to [https://chirpy-test-XXXX.ue.r.appspot.com]You can stream logs from the command line by running:$ gcloud app logs tail -s defaultTo view your application in the web browser run:$ gcloud app browse 위와 같이 순조롭게 마치면 좋겠지만, 난 3번의 시도 끝에 성공했다. ERROR 메세지에 안내된 주소로 가봐도 Cloud Build API 사용이 이미 설정되어 있었기에 시스템에 적용될 때까지 시간이 필요하다길래 기다리면서 계속 시도했다. 근데 또 한가지 찜찜한 점이 있다. 내가 작성한 url과 target url의 region 부분이 다르다. 난 asia-northeast3이라 썼는데 du로 바뀌어 있다. 어쨌든 콘솔에 뜬 target url을 인터넷 주소창에 입력한 후 맨 마지막에 /admin을 추가하고 이동한다. Manage Users에서 자신의 이메일 주소를 추가한다. Authorize Access 클릭. Authorize Access를 클릭하고 내 구글 아이디로 로그인을 하니 웬걸 403 오류: access_denied 가 계속 떴다. 아니 내가 관리자인데 왜 자꾸 액세스 권한이 없다는 거야???? 심지어 액세스 권한 요청은 또 개발자인 나 (내 이메일 주소)한테 연락을 하란다. 정말 답답해 죽는 줄 알았다. 도대체 왜 안 되는 걸까….여기서 시간 소모를 엄청 했다. 드디어 찾아낸 해결 방법 : API 및 서비스의 OAuth 동의 화면에서 테스트 사용자에 내가 사용할 구글 계정을 추가해야 한다. 앱 게시 상태가 일단 테스트인데, 이건 나중에 필요하면 앱 게시 해봐야겠다. 하지만 곧바로 또 다시 다른 난관에 봉착..,..Privacy error로 사이트가 안전하지 않아 연결을 안 해준다… 뭐가 잘못된 걸까….. 오늘 다 끝내고 싶었는데 안 되겠다,,, 내일 다시 이어서 해야지….다시 해결!!!!!! ‘연결이 비공개로 설정되어 있지 않습니다.’ 가 뜬 창의 주소 url의 https를 http로 바꿔준다. 또, 이전에 내가 찜찜하다고 한 du 부분,,,분명 난 Redirect URI에 asia-northeast3을 썼지만,,, gcloud app deploy에서는 바뀌었기 때문에 주소창에서 이 부분을 수정하니 드디어! continue를 누르면 :다음 단계로 넘어갈 수 있는 창이 뜬다.Google Analytics Query 만들기 Create Query -&gt; Query Explorer 를 이용해 query를 만들어 보자. id : ga:XXXX 형식 start-date : 블로그 첫 글 개시 날짜 end-date : today metrics : ga:pageviews dimensions : ga:pagePath filters : ga:pagePath=~^/posts/.*/$;ga:pagePath!@= site.baseurl을 지정했다면, ga:pagePath=~^/BASE_URL/posts/.*/$ 안 된다. 자료가 많이 오래됐나? 아무튼 UA가 아닌 GA4 사용해야 하고,,, 이리 저리 해본 끝에 게시글에 조회수 항목이 생겼지만 계속 로딩만 뜨고.. Google Analytics도 제대로 되고 있는 건가 잘 모르겠다..결론그래도 설명글을 쭉 따라하면 잘 될 줄 알았는데 복병이 너무 많았다,,,, JAVA 처음 배웠을 때 실습 프로젝트로 게시판 만들고 글에 조회수 추가하는 간단한 방법이 그리워졌다…. 검색해 보니 이 방법은 아무도 쓰지 않는 것 같아 보였고…..결론은 조회수 기능을 쉽게 제공해 주는 다른 블로그 플랫폼이나 HITS인가 를 추천한다. 사람들이 많이 쓰는 것 같다 사용법도 간단하다고,,,,역시 혼자 고생하는 거 보단 대세를 따르는 게 좋을 듯 하다. 하지만 나는 이 방법으로 꼭 성공해보고 싶으니 계속 시도할 거다." }, { "title": "깃허브 블로그 만들다 안 될 때 (Chirpy 테마)", "url": "/posts/github-blog/", "categories": "Blogging, Tutorial", "tags": "github, blog, jekyll, chirpy", "date": "2022-03-30 18:20:00 +0900", "snippet": "서론이 글은 검색만 해도 수두룩하게 나오는 깃허브 블로그를 개설 설명 글대로 똑같이 따라했지만 어,,, 왜 안 되지? 간단한 것 같은데, 똑같이 했는데 왜 나만 안 되는 거야? 라는 상황을 겪은 과거의 나와 같은 사람들을 위해 쓰는 글이다.왜 안 돼?테마 적용깃허브 블로그 개설 설명글을 보면 테마 적용은 정말 정말 쉽다. 각종 Jekyll Themes 사이트에서 원하는 테마를 다운받아 압축을 해제하고 그 안의 내용물을 그대로 로컬 블로그 폴더 안에 복붙하면 된다고 한다. 하지만 그 많고 많은 테마 중 Chirpy를 골랐다면 축 당첨 이다.제일 먼저 다운로드 후 git push를 할 때 아래와 같은 오류가 뜰 수 있다 :GitHub 설정에서 본인이 사용하고 있는 Personal access token의 scope에 workflow를 추가해주면 금방 해결된다. Github 로그인 -&gt; 오른쪽 상단 프로필 사진 클릭 후 Settings -&gt; Developer Settings -&gt; Personal access tokens -&gt; 사용 중인 토큰 이름 클릭 -&gt; Select scopes 에서 workflow 체크 -&gt; Update token하지만 1, 테마를 깃허브에 푸시 했다고 해서 바로 적용이 되는 것은 아니다.이 Chirpy 테마를 이용하고자 한다면 복붙 이후에 해당 리포지터리에서 아래 명령어를 수행해야 한다 :$ bash tools/init.sh 위 명령어의 역할은 아래 파일들 삭제 : .travis.yml _posts 폴더의 하위 파일들 .gitignore에서 Gemfile.lock 제거. 수정 사항에 대한 새로운 commit 자동 생성. 등 이다.성공했다면 아래와 같이 나올 것이다 :이후$ git push를 다시 수행하면 깃허브의 리포지터리 Actions에서 어떤 Automatic build가 실행되는 것을 확인할 수 있다.하지만 2, 실행이 끝난 후 초록불 대신 빨간불이 들어올 수 있다.이것도 간단히 해결할 수 있다.init.sh에 의해 제거 되었던 Gemfile.lock을 다시 .gitignore에 추가해주고 Gemfile.lock 파일을 리포지터리에서 삭제해 주자.그리고 다시 git push를 해주면 정상적으로 빌드가 진행되어 초록불을 마주할 수 있다.마지막으로!!! 빌드 성공 후 깃허브 리포지터리에 gh-pages가 새롭게 생긴 것을 확인했다면 publishing source를 이 브랜치로 변경해야 한다. GitHub 블로그 리포지터리의 Settings -&gt; Pages -&gt; Source 아래 /(root)의 브랜치 gh-pages 선택 -&gt; Save이 작업을 끝으로 Chirpy 테마 적용은 끝!이라고 생각하고 두근대는 마음으로 mamulee.github.io로 들어가봤지만 어라 왜 또 안 되는 거야@!!!@찐막 : _config.yml 수정진짜 진짜 마지막으로 _config.yml 파일을 열어 url에 본인의 블로그 주소를 넣자.url: \"https://&lt;github-username&gt;.github.io/\"url 이외의 항목들은 본인의 환경에 맞춰 알아서 수정하면 된다. 이후 모든 수정 사항들을 git commit, git push 해주면 드디어 내 블로그에 테마가 적용된 것을 확인할 수 있다. 수정 반영이 오래 걸릴 수 있으니 Actions에서 수시로 오류가 나진 않았는지 빌드가 완료되었는지 확인 후 블로그를 새로고침 해보는 것이 좋다.결론혹여나 나처럼 장문이나 영어 울렁증이 있는 사람들을 위해 이 글을 작성했지만, Chripy 테마는 예쁜만큼 각 파일에 설명 또한 너무 잘 되어있기 때문에 Demo 페이지나 다운 받은 테마 파일의 _posts 폴더 안 5가지의 .md파일의 내용을 참고하면 더 많은 도움이 될 것이다." } ]
