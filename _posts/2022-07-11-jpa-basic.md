---
title: 강의 필기 - 자바 ORM 표준 JPA 프로그래밍 - 기본편
author: mamulee
date: 2022-07-11 19:00:00 +0900
categories: [Studying, Notes]
tags: []
img_path: /assets/img/jpa-basic/
---

# 자바 ORM 표준 JPA 프로그래밍 - 기본편

## JPA 소개

장점
- 개발 속도 향상
- 유지보수성 증가

실무에서 어려운 이유
1. 객체와 테이블의 설계와 올바른 맵핑
2. JPA 내부 동작방식에 대한 이해


## JPA와 모던 자바 데이터 저장 기술

### SQL 중심적인 개발의 문제점
- 대부분 객체를 관계형 DB에 저장 관리.
  - 모두 SQL
- 무한 반족, 지루한 코드
- 필드가 추가 되면 유지보수가 쉽지 않음.
- 패러다임의 불일치
  - 객체 vs. 관계형 데이터베이스
    - 상속
      - 객체 존재
      - 디비 X, 그나마 유사한 것이 "슈퍼타입 서브타입 관계"
    - 연관관계
      - 객체 : 참조 사용
      - 테이블 : 외래 키 사용
    - 데이터 타입
    - 데이터 식별 방법

### JPA
- Java Persistence API
- 자바 진영의 ORM 기술 표준
- 인터페이스의 모음

JPA를 왜 사용해야 하는가?
- SQL 중심적인 개발에서 객체 중심으로 개발
- 생산성
  - 저장 : jpa.persist(member)
  - 조회 : jpa.find(member)
  - 수정 : member.setName("newName")
  - 삭제 : jpa.remove(member)
- 유지보수
  - 필드 변경 시 SQL은 JPA가 해결
- 패러다임의 불일치 해결
  - 상속
    - 저장 : 알아서 2가지 insert 문 생성
    - 조회 : 알아서 join 문 생성
  - 연관관계
    - 신뢰할 수 있는 엔티티
      - 동인한 트랜잭션 내 조회한 엔티티는 같다.
- 성능
  - 1차 캐시와 동일성 (identity) 보장
    - 같은 트랜잭션 안에서는 같은 엔티티 반환
    - DB Isolation Level이 Read commit 이어도 애플리케이션에서 Repeatalbe Read 보장
  - 트랜잭션을 지원하는 쓰기 지연 (transactional write-behind)
    - 트랜잭션 커밋 전까지 SQL을 모았다가 한번에 전송
  - 지연 로딩 (Lazy Loading)
    - 객체가 실제 사용될 때 로딩
- 데이터 접근 추상화와 벤더 독립성
- 표준

## JPA 시작

### 프로젝트 생성
H2 데이터 베이스 설치와 실행

IntelliJ 프로젝트 생성
- JAVA 8
- Maven
  - pom.xml 설정
    - dependency 추가
      - h2database version은 다운한 것과 일치해야 함.

JPA 설정하기 - persistence.xml
- 위치 : /META-INF/persistence.xml
- 데이터베이스 방언
  - hibernate.dialect 속성에 지정
  - 원하는 특정 DB 기능 사용 원할 시.
  - hibernate 전용 옵션

> `ERROR: Database "/Users/이름/test" not found, either pre-create it or allow remote database creation (not recommended in secure environments) [90149-214]`
>
> 오류 해결 방법 :
> 1. ./h2.sh 실행 종료
> 2. `JDBC URL` : jdbc:h2:~/test 로 접속 후
> 3. `JDBC URL` : jdbc:h2:tcp://localhost/~/test 로 다시 시도
{: .prompt-danger }

### 애플리케이션 개발

## 영속성 관리 - 내부 동작 방식

영속성 컨텍스트
- 엔티티를 영구 저장하는 환경
- EntityManager.persist(entity);
  - 디비에 저장하는 것이 아니라,
  - entity를 영속성 컨텍스트에 영구적으로 저장한다는 뜻.
- 엔티티의 생명 주기
  - 비영속 (new/transient)
  - 영속 (managed)
  - 준영속 (detached)
  - 삭제 (removed)
- 영속성 컨텍스트의 이점
  - 1차 캐시
    - 조회 시 DB에서 가져오기 전에 먼저 1차 캐시에서 가져온다. (select 쿼리 안 날림)
  - 동일성 (identity) 보장
    - 동일 객체 == 비교 시 true
  - 트랜잭션을 지원하는 쓰기 지연 (transactional write-behind)
    - 쓰기 지연 저장소에 SQL를 쌓아놓고 커밋하는 순간 한꺼번에 보낸다.
    - ```persistence.xml
        <property name="hibernate.jdbc.batch_size" value="10"/>
        ```
{: file="src/main/resources/META-INF/persistence.xml"}

  - 변경 감지 (Dirty Checking)
    - 엔티티와 스냅샷 비교 후 자동으로 UPDATE OR DELETE
- 지연 로딩 (Lazy Loading)

플러시
- 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영.
- em.flush() - 직접 호출
- 트랜잭션 커밋 - 플러시 자동 호출
- JPQL 쿼리 실행 - 플러시 자동 호출
- 1차 캐시를 지우는 것이 아님.
- 쓰기 지연 저장소에 있는 것들이 데이터베이스에 반영이 되는 것.
- 플러시 모드 옵션
  - FlushModeType.AUTO
    - 커밋이나 쿼리를 실행할 때 플러시 (기본값)
  - FlushModeType.COMMIT
    - 커밋할 때만 플러시

준영속 상태
- 영속 상태의 엔티티가 영속성 컨텍스트에서 분리.
- 영속성 컨텍스트가 제공하는 기능을 사용 못함.
- em.detach(entity)
  - 특정 엩티티만 준영속 상태로 전환.
- em.clear()
  - 영속성 컨텍스트를 완전히 초기화. (1차 캐시 지움)
- em.close()
  - 영속성 컨텍스트를 종료.


## 엔티티 매핑

객체와 테이블 매핑 : @Entity, @Table
- @Entity
  - JPA가 관리하는 엔티티
  - 기본 생성자 필수
  - final 클래스, enum, interface, inner 클래스 사용 X
  - 저장할 필드에 final 사용 X
  - 속성
    - name (기본값 = Class 이름)
- @Table

데이터베이스 스키마 자동 생성
- 어플리케이션 실행 시점에 DDL 자동 생성
- 객체 중심!
- 데이터베이스 방언을 활용해 DB에 맞는 적절한 DDL 생성
  - 개발 장비에서만 사용
  - 운영 서버에서는 적절히 다듬어서 사용
- 속성
  - create
    - 시작 전 테이블 drop 후 생성
  - create-drop
    - 시작 전 테이블 drop 후 생성
    - 이후 종요 시점에서 다시 drop
  - update
    - 기존 테이블 drop 대신 alter
    - 필드 삭제는 불가, 추가만 가능
  - validate
    - 엔티티와 테이블이 정상 매핑되었는지 확인
  - none
    - 기능을 사용 안 함.
  - * 운영 장비에서는 사용 X


필드와 컬럼 매핑
- @Column
  - 컬럼 매핑
- @Temporal
  - 날짜 타입 매핑
  - 최신 버전 하이버네이트는 굳이 명시할 필요 없음
- @Enumerated
  - enum 타입 매핑
- @Lob
  - BLOB, CLOB 매핑
- @Transient
  - 특정 필드를 컬럼에 매핑하지 않음(매핑 무시)

기본 키 매핑
- @Id
  - 기본 키 값을 직접 할당
- @GeneratedValue
  - 함께 사용 시 값 자동 생성
  - IDENTITY
    - 데이터베이스에 위임, MySQL
    - 디비에 insert 돼야 기본 키 값을 알 수 있음.
      - 그래서 예외적으로 persist() 실행 시 바로 insert 문을 날린다. (commit 까지 안 기다림)
      - 이후 바로 select 해옴 (내부적으로 insert 시점에 바로 return 받음)
  - SEQUENCE
    - Long 사용 권장
    - 데이터베이스 시퀀스 사용, Oracle
    - @SequenceGenerator 필요
      - 데이터베이스에 시퀀스 생성 시
    - 기본 키 값을 알기 위해 "call next value for" 시퀀스가 persist 전에 실행 된다.
      - allocationSize를 통해 성능 최적화 가능.
        - call next value for을 매번 가져오는 대신 미리 설정 개수만큼 가져온다.
        - 처음에 2번 호출해서 1, 개수 N+1, 그리고 그 다음부터는 메모리에서 호출
  - TABLE
    - 키 생성 전용 테이블 하나 생성 후 시퀀스 흉내
    - 모든 데이터베이스 적용 가능
    - @TableGenerator 필요
      - 이것도 allocationSize 있음
- 권장하는 식별자 전략
  - Long 형 + 대체키 + 키 생성 전략 사용

연관관계 매핑 : @ ManyToOne, @JoinColumn

## 연관관계 매핑 기초

연관관계가 필요한 이유
- 객체를 테이블에 맞춰 모델링 시
  - 외래 키 식별자를 직접 다룸
  - 식별자로 다시 조회
  - 객체 지향적이지 않음.


단방향 연관관계
- @ManyToOne
- 객체지향적
- 객체 자체를 set 해서 가져올 때 알아서 join 하는 객체의 기본키를 가져옴.

양방향 연관관계와 연관관계의 주인
- @ManyToOne <-> @OneToMany
  - 역방향도 조회 가능
- 객체의 양방향 관계
  - 서로 다른 두 개의 단방향 관계
- 테이블의 양방향 관계
  - 외래 키 하나로 양방향 관계
- 연관관계 주인 (Owner)
  - 주인
    - mappedBy 속성 X
    - `외래 키가 있는 곳`
  - 주인 X
    - mappedBy 속성으로 주인 지정

양방향 매핑 시 가장 많이 하는 실수
- 연관관계의 주인에 주인 아닌 것들의 값을 입력 안 함.
- 주인 아닌 것에 주인의 값을 입력 안 해도 호출 시 JPA가 자동으로 select 문을 날려서 가져온다. (flush(), clear() 시)
  - 하지만 순수 객체 상태를 고려하면 (flush(), claer() 안 하면 영속성 상태, 1차 캐시에 없음, 조회 안 됨.) 양쪽에 모두 값을 입력해줘야 한다.
  - 실수 방지를 위해 주인에 값 세팅 시 그 메소드 안에서 반대 방향의 객체에 자기 자신을 입력해 준다. (`this`)
    - 연관관계 편의 메소드 이용 (Setter 대신 권장)
      - 아무쪽에나, 둘 중 하나에 메소드 생성
    - 무한 루프 조심!

양방향 매핑 정리
- 단반향 매핑만으로도 이미 연관관계 매핑은 완료.
- 양방향 매핑은 역방향 조회 (객체 그래프 탐색) 기능이 추가된 것 뿐.
- JPQL에서 역방향으로 탐색할 일이 많음.
- 단방향 매핑을 잘하고 양방향은 필요할 때 추가해도 됨.
  - 테이블에 영향을 주지 않음.


## 다양한 연관관계 매핑

### 연관관계 매핑 시 고려사항 3가지
- 다중성
  - 다대일 (@ManyToOne)
  - 일대다 (@OneToMany)
  - 일대일 (@OneToOne)
  - 다대다 (@ManyToMany)
- 단방향 , 양방향
- 연관관계의 주인

### 다대일 [N : 1]
- 단방향
  - 가장 많이 사용.
  - 반대는 일대다.
- 양방향
  - 왜래 키가 있는 쪽이 주인.
  - 양쪽을 서로 참조.

### 일대다 [1 : N]
- 단방향
  - 1이 연관관계 주인.
  - 다 쪽에 외래 키 있음.
    - 여기를 추가 Update 침.
  - @JoinColumn 필수.
  - 비추. 일대다 단방향 보다는 다대일 양방향 매칭 권장.
- 양방향
  - 공식적으로 존재 X
  - @JoinColumn (inserttable = false, updatable = false)
  - 읽기 전용 필드
  - 다대일 양방향 사용 권장.

### 일대일 [1:1]
- 외래 키 위치 선택 가능.
  - 유니크 제약 조건 추가 필요
- 주 테이블에 왜래 키 단방향
  - 다대일과 유사.
- 주 테이블에 외래키 양방향
  - 외래키가 있는 곳이 주인.
- 대상 테이블에 외래 키 단방향
  - JPA 지원 X
- 대상 테이블에 외래 키 양방향
  - 주 테이블 왜래 키 양방향과 매핑 방법 같음.

### 다대다 [N : M]
- 관계형 디비에서는 표현 불가.
- 연결 테이블 추가해서 일대다, 다대일 관계로 풀어내야 함.
- 객체는 가능.


## 고급 매핑

### 상속 관계 매핑
- 객체의 상속 구조와 데이터베이스의 슈퍼타입 서브타임 관계를 매핑
- 부모 클래스는 추상 클래스
- 슈퍼타입 서브타입 논리 모델 -> 물리 모델 전환 방법
  - 조인 전략
  - 단일 테이블 전략
  - 구현 클래스마다 테이블 전략
- @Inheritance(strategy=Inheritance.Type.XXX)
  - JOINED : 조인 전략
    - insert 쿼리 2번
    - 조회 시 join 사용.
  - SINGLE_TABLE : 단일 테이블 전략
    - insert 쿼리 1번
    - 조회 시 join 필요 없음.
  - TABLE_PER_CLASS : 구현 클래스마다 테이블 전략
    - 부모 테이블 존재 X.
      - 자식들에 부모 테이블에 있던 필드들이 중복으로 들어감.
    - 부모 객체로 조회 시 모든 테이블 조회 필요 -> 긴 쿼리 수행, 성능 안 좋음.
- @DiscriminatorColumn
  - DTYPE이 자동으로 테이블에 컬럼으로 생김.
  - 자식 객체명이 들어감.
    - @DiscriminatorValue("뭥하는 값")으로 변경 가능.
  - 단일 테이블 전략에서는 필수!

### @MappedSuperclass
- 공통 매핑 정보가 필요할 때 사용
  - 각 클래스에서 중복 되는 필드
    - e.g. id, name
- 공통 필드를 가진 클래스에 명시
- 조회, 검색 불가. 추상 클래스 권장